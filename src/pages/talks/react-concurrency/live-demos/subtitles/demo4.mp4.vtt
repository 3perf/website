WEBVTT

00:00.000 --> 00:12.260
 So, I switch back to the app, and I click record again, and I try typing into the filter,

00:12.260 --> 00:20.400
 and I stop recording, and now I still see a single expensive spike of CPU activity,

00:20.400 --> 00:24.920
 but if I zoom into this spike, if I look into what's happening here, instead of a single

00:24.920 --> 00:30.160
 huge JavaScript task, and let me just let me remind you how this was before we implemented

00:30.160 --> 00:31.160
 this optimization.

00:31.160 --> 00:37.680
 So, I'm going to comment this out, and click record, hold on, let me remove this.

00:37.680 --> 00:42.160
 Click record, press F, stop recording.

00:42.160 --> 00:49.880
 So, before this looked like this, we were pressing the keyboard button, and this was

00:49.880 --> 00:55.200
 triggering the whole app to re-render, and this was taking, sorry, this was taking, this was

00:55.200 --> 00:58.280
 blocking the page for 600 milliseconds.

00:58.280 --> 01:05.800
 Now, with concurrent rendering, what happens is instead of blocking the page that is having

01:05.800 --> 01:10.440
 a single huge expensive chunk of JavaScript, which renders all your components in a row,

01:10.440 --> 01:18.120
 what you have is you have these single small, individual small tasks of JavaScript, each

01:18.120 --> 01:27.960
 of which takes just five, six, seven milliseconds, and each of which renders just several components

01:27.960 --> 01:33.960
 at a time, like, we have a function call, and the function call renders RectMarkdown, calls

01:33.960 --> 01:41.880
 RectMarkdown, calls RectMarkdown, RectMarkdown, a bunch of RectMarkdown components, and, yeah,

01:41.880 --> 01:46.760
 the NotesList component, so React starts rendering the components, React renders some

01:46.760 --> 01:50.600
 components, and then React gives back control to the browser.

01:50.600 --> 01:52.480
 So this is how it looks.

01:52.480 --> 02:19.840
 Now, how does it actually work?

