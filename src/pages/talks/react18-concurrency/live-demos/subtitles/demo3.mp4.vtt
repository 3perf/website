WEBVTT

00:00.000 --> 00:04.760
 Look, here's the code for my Sidebar component,

00:04.760 --> 00:09.360
 for this yellow component that I have on the side of the app.

00:09.360 --> 00:12.680
 What I have in this component is I have three child components.

00:12.680 --> 00:15.280
 I have the FilterInput component, which

00:15.280 --> 00:18.080
 renders the filter input.

00:18.080 --> 00:23.040
 I have the NotesList component, which renders the notes list.

00:23.040 --> 00:24.940
 And I have the NoteControls component,

00:24.940 --> 00:27.760
 which renders a bunch of buttons.

00:27.760 --> 00:31.200
 And another thing this component has

00:31.200 --> 00:36.680
 is a single bit of state called filter.

00:36.680 --> 00:39.280
 And so the single bit of state called filter,

00:39.280 --> 00:43.840
 it is updated every time I'm typing into the filter input.

00:43.840 --> 00:48.040
 And it controls both the FilterInput and the NotesList.

00:48.040 --> 00:49.920
 So every time I'm typing into the FilterInput,

00:49.920 --> 00:56.520
 my FilterInput re-renders and my NotesList re-renders.

00:56.520 --> 01:03.200
 So OK, now one thing React 18 introduces

01:03.200 --> 01:05.240
 is non-urgent updates.

01:05.240 --> 01:11.280
 And to start applying these optimizations,

01:11.280 --> 01:13.360
 I needed to tune my mental model a bit.

01:13.360 --> 01:18.160
 I needed to learn to look at the app

01:18.160 --> 01:21.320
 and try to figure out, OK, which of these components

01:21.320 --> 01:25.480
 need to be updated immediately, urgently, synchronously?

01:25.480 --> 01:27.920
 And which of these components could

01:27.920 --> 01:32.440
 be updated non-urgently, like not blocking

01:32.440 --> 01:35.840
 the page with a delay?

01:35.840 --> 01:39.200
 And so if I look at this app, I would

01:39.200 --> 01:44.840
 realize that in this case, this state controls two components.

01:44.840 --> 01:49.320
 It controls the FilterInput, and it controls the NotesList.

01:49.320 --> 01:54.320
 But what actually happens here is the FilterInput component

01:54.320 --> 01:56.880
 is the component that needs to update immediately.

01:56.880 --> 02:00.560
 Every time I'm typing into the editor, into the input,

02:00.560 --> 02:02.160
 I need the input to update immediately,

02:02.160 --> 02:05.280
 because otherwise the app would feel laggy.

02:05.280 --> 02:10.280
 But the NotesList thing, it doesn't

02:10.280 --> 02:12.360
 need to update right away.

02:12.360 --> 02:13.960
 It could lag.

02:13.960 --> 02:19.000
 I, as a user, am perfectly OK with the filter list

02:19.000 --> 02:22.920
 lagging a second after my input if the app stays responsive.

02:22.920 --> 02:25.040
 I'm good with that.

02:25.040 --> 02:27.840
 And so the way we would typically implement this optimization

02:27.840 --> 02:30.280
 is, indeed, with debouncing and throttling,

02:30.280 --> 02:32.440
 you would wrap your input event with, like,

02:32.440 --> 02:34.480
 lodash.debounce or lodash.throttle,

02:34.480 --> 02:38.120
 and you would make sure it runs less frequently.

02:38.120 --> 02:43.920
 But what React allows you to do is

02:43.920 --> 02:45.760
 React gives you another primitive

02:45.760 --> 02:50.120
 for implementing a better optimization, an optimization

02:50.120 --> 02:52.720
 that doesn't have drawbacks of debouncing and throttling.

02:52.720 --> 02:57.760
 And this primitive is non-urgent updates.

02:57.760 --> 03:03.320
 So to use non-urgent updates, I need to do two things.

03:03.320 --> 03:08.480
 The first thing is, I need to take my single state,

03:08.480 --> 03:10.560
 and I need to split it into two states.

03:10.560 --> 03:12.760
 One of these states would be urgent,

03:12.760 --> 03:15.480
 and the other of these states would be non-urgent.

03:15.480 --> 03:23.280
 So I'd call the first state filterInput.

03:23.280 --> 03:25.640
 And I'd call the second state, oh, sorry,

03:25.640 --> 03:26.760
 yeah, setFilterInput.

03:26.760 --> 03:31.120
 All right, this is going to be slow.

03:31.120 --> 03:34.960
 Ooh, I'm bad with keyboards.

03:34.960 --> 03:37.960
 The second state would be called filterValue

03:37.960 --> 03:39.280
 and setFilterValue.

03:39.280 --> 03:41.960
 And now the filterInput would be

03:41.960 --> 03:46.120
 passed into the FilterInput component,

03:46.120 --> 03:47.640
 and the filterValue will be passed

03:47.640 --> 03:50.120
 into the NotesList component.

03:50.120 --> 03:59.920
 And I would also call both setState hooks whenever I am,

03:59.920 --> 04:05.920
 wrong line, whenever I detect input updates.

04:05.920 --> 04:11.640
 And one more thing, let's upgrade to React 18,

04:11.640 --> 04:14.880
 if only it was so easy.

04:14.880 --> 04:17.280
 So now we have the app running in the React 18 mode.

04:17.280 --> 04:21.560
 And if I tried typing into the filter input,

04:21.560 --> 04:23.280
 it would still feel slow.

04:23.280 --> 04:26.120
 Like I try typing, and look, it's lagging.

04:26.120 --> 04:27.240
 The spinner still lags.

04:27.240 --> 04:30.960
 And if I tried to type a bunch of letters,

04:30.960 --> 04:34.080
 it would get slow and stuff.

04:34.080 --> 04:36.080
 So we didn't do anything yet.

04:36.080 --> 04:40.520
 We just duplicated the state, and we made our app worse.

04:40.520 --> 04:47.800
 But what I can do now is I could take the second setState call,

04:47.800 --> 04:50.760
 and I could wrap it with a function called startTransition.

04:55.080 --> 04:59.520
 And by doing this, I would tell React that, look,

04:59.520 --> 05:04.280
 this setState call is not urgent.

05:04.280 --> 05:07.880
 So what you could do, React, you could take the setState call,

05:07.880 --> 05:11.640
 and you could run it without blocking the page.

05:11.640 --> 05:13.560
 And let's see how this works.

05:13.560 --> 05:14.400
 So I apply this.

05:14.400 --> 05:15.040
 Oh, no, hold on.

05:15.040 --> 05:18.280
 I need the startTransition function from somewhere, right?

05:18.280 --> 05:22.040
 So I could import it straight from React.

05:22.040 --> 05:23.240
 This would work.

05:23.240 --> 05:24.920
 Or I could use the hook useTransition,

05:24.920 --> 05:28.880
 which has one minor benefit.

05:28.880 --> 05:34.040
 It also lets you to learn when the component is transitioning.

05:34.040 --> 05:37.240
 isPending, startTransition equals useTransition.

05:37.240 --> 05:39.280
 So startTransition is a function

05:39.280 --> 05:41.520
 that you wrap your state updates into.

05:41.520 --> 05:47.480
 And isPending is a thing that you could tune the app

05:47.480 --> 05:50.520
 to show that the app is transitioning,

05:50.520 --> 05:52.600
 that there's something that's lagging behind,

05:52.600 --> 05:55.200
 like me setting opacity here.

05:55.200 --> 05:57.640
 And so let's see how this works now.

05:57.640 --> 06:01.520
 So pay attention to the spinner.

06:01.520 --> 06:05.360
 I'm typing, and the spinner doesn't lag.

06:05.360 --> 06:08.000
 The whole list of components re-renders,

06:08.000 --> 06:10.320
 I could even open DevTools to show you.

06:10.320 --> 06:13.760
 The whole list of components re-renders,

06:13.760 --> 06:17.480
 and this takes a second.

06:17.480 --> 06:19.240
 Like, it lags by a second.

06:19.240 --> 06:20.920
 It takes a second for it to render.

06:20.920 --> 06:24.000
 But the spinner does not lag.

06:24.000 --> 06:27.360
 I can type a bunch of letters, and this would still

06:27.360 --> 06:28.640
 be responsive.

06:28.640 --> 06:29.920
 This would update immediately.

06:29.920 --> 06:32.400
 I can remove everything.

06:32.400 --> 06:33.160
 Look, I'm typing it.

06:33.160 --> 06:36.360
 And it's almost like magic.

06:36.360 --> 07:03.360
 It's so super cool.

